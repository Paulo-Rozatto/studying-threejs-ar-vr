<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body id="body">
    <canvas id="output"></canvas>

    <video id="video" playsinline
        style="-webkit-transform: scaleX(-1); transform: scaleX(-1); visibility: hidden; width: auto; height: auto;">
    </video>
</body>

<!-- Load TensorFlow.js -->
<script src="https://unpkg.com/@tensorflow/tfjs"></script>
<!-- Load Posenet -->
<script src="https://unpkg.com/@tensorflow-models/posenet">
</script>
<!-- <script src="../../libs/dat.gui.min.js"></script> -->
<script src="../../libs/stats.min.js"></script>
<script type="text/javascript">
    let stats = initStats()

    // let gui = new dat.GUI();

    // const controls = {
    //     size: video.width / window.innerWidth
    // }
    // let w = video.width;
    // let h = video.height;

    // gui.add(controls, 'size', 0.1, 1.0, 0.05).onChange(change);


    posenet.load().then(async function (net) {
        const imageScaleFactor = 0.50;
        const flipHorizontal = false;
        const outputStride = 16;
        const MIN_SCORE = 0.5;

        const FPS = 60;
        const video = document.getElementById('video');
        const fpsDisplay = document.getElementById('stats');

        await startVideo(video);
        video.width = video.videoWidth;
        video.height = video.videoHeight;

        const canvas = document.getElementById("output");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const radius = 3;
        const ctx = canvas.getContext("2d");

        ctx.fillStyle = "#FF0000";
        ctx.strokeStyle = "#FFFF00";
        ctx.lineWidth = 3;

        let pose //= await net.estimateSinglePose(video, imageScaleFactor, flipHorizontal, outputStride);;

        let begin, delay; // fps helpers
        async function processVideo() {
            begin = Date.now();
            stats.update();

            pose = await net.estimateSinglePose(video, imageScaleFactor, flipHorizontal, outputStride);

            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fill();

            ctx.fillStyle = "#FF0000";

            let offsetX = canvas.width / video.width,
                offsetY = canvas.height / video.height;

            if (canvas.width >= canvas.height) {
                ctx.drawImage(video, 0, (canvas.height / 2) - (canvas.width * video.height / video.width / 2), canvas.width, canvas.width * video.height / video.width);
            } else {
                ctx.drawImage(video, (canvas.width - video.width * offsetX) / 2, 0, video.width * offsetX, canvas.height);
            }

            // console.log(pose);

            let adjacent = posenet.getAdjacentKeyPoints(pose.keypoints, 0)
            // console.log(adjacent)

            ctx.beginPath()
            let kp;

            // Desenha pontos do rosto que nao sao objtidos pelo getAdjacentKeyPoints()
            for (let i = 0; i < 5; i++) {
                kp = pose.keypoints[i];

                if (kp.score > MIN_SCORE) {
                    ctx.moveTo(kp.position.x * offsetX + radius, kp.position.y * offsetY);
                    ctx.arc(kp.position.x * offsetX, kp.position.y * offsetY, radius, 0, 2 * Math.PI);
                }
            }

            // Desenha pointos ajacentes e traca linha caso os dois tenham bom score
            ctx.strokeStyle = "#FF0000";
            for (let pair of adjacent) {
                for (let i = 0; i < 2; i++) {
                    if (pair[i].score > MIN_SCORE) {
                        ctx.moveTo(pair[i].position.x * offsetX + radius, pair[i].position.y * offsetY);

                        // if (pair[i].position.y * offsetY < canvas.height)
                        ctx.arc(pair[i].position.x * offsetX, pair[i].position.y * offsetY, radius, 0, 2 * Math.PI);
                    }
                }

                if (pair[0].score > MIN_SCORE && pair[1].score > MIN_SCORE) {
                    ctx.lineTo(pair[0].position.x * offsetX, pair[0].position.y * offsetY);
                }
            }
            ctx.fill();
            ctx.stroke();


            delay = 1000 / FPS - (Date.now() - begin);
            setTimeout(() => {
                // fpsDisplay.innerText = (1000 / (Date.now() - begin)).toFixed(0);
                processVideo();
            }, delay);
        }

        setTimeout(processVideo, 0);

        function change() {
            // w = controls.size * window.innerWidth;
            // h = controls.size * window.innerHeight;

            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
        }
        window.addEventListener('resize', change, false);
    });


    async function startVideo(video) {
        let stream; // video stream

        const constraints = {
            video: {
                facingMode: "user",
                width: { ideal: 4096 },
                height: { ideal: 2160 }
            },
            audio: false
        }

        try {
            stream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = stream;
            video.play();

            return new Promise(function (resolve, reject) {
                video.addEventListener('loadeddata', function () {
                    resolve();
                });
            });
        }
        catch (err) {
            console.error('Error accesing camera:', err);
            alert('Error accessing camera')
        }
    }

    function initStats() {
        let stats = new Stats();
        stats.setMode(0); // 0: fps, 1: ms

        // Align top-left
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';
        document.getElementById('body').appendChild(stats.domElement);

        return stats;
    }
</script>

</html>