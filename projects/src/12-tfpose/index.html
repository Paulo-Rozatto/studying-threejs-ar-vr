<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body id="body">
    <canvas id="output"></canvas>

    <video id="video" playsinline
        style="-webkit-transform: scaleX(-1); transform: scaleX(-1); visibility: hidden; width: auto; height: auto;">
    </video>
</body>

<!-- Load TensorFlow.js -->
<script src="https://unpkg.com/@tensorflow/tfjs"></script>
<!-- Load Posenet -->
<script src="https://unpkg.com/@tensorflow-models/posenet">
</script>
<!-- <script src="../../libs/dat.gui.min.js"></script> -->
<script src="../../libs/stats.min.js"></script>
<script type="text/javascript">
    let stats = initStats()

    // let gui = new dat.GUI();

    // const controls = {
    //     size: video.width / window.innerWidth
    // }
    // let w = video.width;
    // let h = video.height;

    // gui.add(controls, 'size', 0.1, 1.0, 0.05).onChange(change);


    posenet.load().then(async function (net) {
        const imageScaleFactor = 0.75;
        const flipHorizontal = false;
        const outputStride = 16;
        const MIN_SCORE = 0.1;

        const FPS = 60;
        const video = document.getElementById('video');
        const fpsDisplay = document.getElementById('stats');

        await startVideo(video);
        video.width = video.videoWidth;
        video.height = video.videoHeight;

        const canvas = document.getElementById("output");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const radius = 3;
        const ctx = canvas.getContext("2d");

        ctx.fillStyle = "#FF0000";
        ctx.strokeStyle = "#FFFF00";
        ctx.lineWidth = 3;

        const MAX_RELATIVE = 0.1 // biggest displacement allowed in percetage of the image
        let MAX_SQUARED = squareDistace({ x: 0, y: 0 }, { x: canvas.width, y: canvas.height }) * Math.pow(MAX_RELATIVE, 2);

        const DIFFS_TO_RESET = 8;
        const FRAMES_TO_RESET = 10;
        let lastCont, drawCont;
        let pose, renderPose, lastPose;
        // let selectedPose

        renderPose = await net.estimateSinglePose(video, imageScaleFactor, flipHorizontal, outputStride);

        let pause = false;

        let isTimer = true;
        let interval;

        // window.addEventListener('keydown', () => {
        //     pause = !pause;

        //     if (!pause) {
        //         setTimeout(processVideo, 0);
        //     }
        // })

        // resetByFrame = FRAMES_TO_RESET;

        let begin, delay; // fps helpers
        async function processVideo() {
            begin = Date.now();
            stats.update();

            pose = await net.estimateSinglePose(video, imageScaleFactor, flipHorizontal, outputStride);

            lastCont = drawCont = 0;

            if (lastPose) {
                for (let i = 0; i < 17; i++) {
                    if (squareDistace(pose.keypoints[i].position, lastPose.keypoints[i].position) > MAX_SQUARED) {
                        pose.keypoints[i].position.x = lastPose.keypoints[i].position.x
                        pose.keypoints[i].position.y = lastPose.keypoints[i].position.y
                        lastCont += 1;
                    }
                }
            }

            for (let i = 0; i < 17; i++) {
                renderPose.keypoints[i].position.x = pose.keypoints[i].position.x
                renderPose.keypoints[i].position.y = pose.keypoints[i].position.y
            }

            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fill();

            ctx.fillStyle = "#FF0000";

            let offsetX = canvas.width / video.width,
                offsetY = canvas.height / video.height;

            if (canvas.width >= canvas.height) {
                ctx.drawImage(video, 0, (canvas.height / 2) - (canvas.width * video.height / video.width / 2), canvas.width, canvas.width * video.height / video.width);
            } else {
                ctx.drawImage(video, (canvas.width - video.width * offsetX) / 2, 0, video.width * offsetX, canvas.height);
            }

            // console.log(pose);

            let adjacent = posenet.getAdjacentKeyPoints(renderPose.keypoints, 0)
            // console.log(adjacent)

            ctx.beginPath()
            let kp;

            // Desenha pontos do rosto que nao sao objtidos pelo getAdjacentKeyPoints()
            for (let i = 0; i < 5; i++) {
                kp = renderPose.keypoints[i];

                if (kp.score > MIN_SCORE) {
                    ctx.moveTo(kp.position.x * offsetX + radius, kp.position.y * offsetY);
                    ctx.arc(kp.position.x * offsetX, kp.position.y * offsetY, radius, 0, 2 * Math.PI);
                    drawCont += 1;
                }
            }

            // Desenha pointos ajacentes e traca linha caso os dois tenham bom score
            ctx.strokeStyle = "#FF0000";
            for (let pair of adjacent) {
                for (let i = 0; i < 2; i++) {
                    if (pair[i].score > MIN_SCORE) {
                        ctx.moveTo(pair[i].position.x * offsetX + radius, pair[i].position.y * offsetY);

                        // if (pair[i].position.y * offsetY < canvas.height)
                        ctx.arc(pair[i].position.x * offsetX, pair[i].position.y * offsetY, radius, 0, 2 * Math.PI);
                        drawCont += 1
                    }
                }

                if (pair[0].score > MIN_SCORE && pair[1].score > MIN_SCORE) {
                    ctx.lineTo(pair[0].position.x * offsetX, pair[0].position.y * offsetY);
                }
            }
            ctx.fill();
            ctx.stroke();

            lastPose = undefined
            lastPose = pose;

            if (pause) return;

            delay = 1000 / FPS - (Date.now() - begin);
            setTimeout(() => {
                processVideo();
            }, delay);
        }

        setTimeout(() => {
            isTimer = false;
            processVideo();
        }, 5000);

        let cont = 5;
        interval = setInterval(() => {
            cont--;
        }, 1000);


        ctx.font = "120px Arial";

        function timer() {
            if (canvas.width >= canvas.height) {
                ctx.drawImage(video, 0, (canvas.height / 2) - (canvas.width * video.height / video.width / 2), canvas.width, canvas.width * video.height / video.width);
            } else {
                ctx.drawImage(video, (canvas.width - video.width * offsetX) / 2, 0, video.width * offsetX, canvas.height);
            }

            ctx.fillText(cont.toString(), canvas.width / 2, canvas.height / 2);

            if (isTimer) {
                delay = 1000 / FPS - (Date.now() - begin);
                setTimeout(() => {
                    timer()
                }, delay);
            }
        }
        setTimeout(timer, 0);

        function squareDistace(p1, p2) {
            let a = p1.x - p2.x;
            let b = p1.y - p2.y;

            return a * a + b * b;
        }

        function change() {
            // w = controls.size * window.innerWidth;
            // h = controls.size * window.innerHeight;

            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            MAX_SQUARED = squareDistace({ x: 0, y: 0 }, { x: canvas.width, y: canvas.height }) * Math.pow(MAX_RELATIVE, 2);
        }
        window.addEventListener('resize', change, false);
    });


    async function startVideo(video) {
        let stream; // video stream

        const constraints = {
            video: {
                facingMode: "user",
                width: { ideal: 720 },
                height: { ideal: 480 }
            },
            audio: false
        }

        try {
            stream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = stream;
            video.play();

            return new Promise(function (resolve, reject) {
                video.addEventListener('loadeddata', function () {
                    resolve();
                });
            });
        }
        catch (err) {
            console.error('Error accesing camera:', err);
            alert('Error accessing camera')
        }
    }

    function initStats() {
        let stats = new Stats();
        stats.setMode(0); // 0: fps, 1: ms

        // Align top-left
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';
        document.getElementById('body').appendChild(stats.domElement);

        return stats;
    }
</script>

</html>