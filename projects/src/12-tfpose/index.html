<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body id="body">
    <canvas id="output"></canvas>

    <video id="video" playsinline
        style="-webkit-transform: scaleX(-1); transform: scaleX(-1); visibility: hidden; width: auto; height: auto;">
    </video>
</body>

<!-- Load TensorFlow.js -->
<script src="https://unpkg.com/@tensorflow/tfjs"></script>
<!-- Load Posenet -->
<script src="https://unpkg.com/@tensorflow-models/posenet">
</script>
<script src="../../libs/dat.gui.min.js"></script>
<script src="../../libs/stats.min.js"></script>
<script type="text/javascript">
    const controls = {
        size: 0.5
    }
    let w = controls.size * window.innerWidth;
    let h = controls.size * window.innerHeight;

    let gui = new dat.GUI();
    let stats = initStats()


    posenet.load().then(async function (net) {
        const imageScaleFactor = 0.20;
        const flipHorizontal = false;
        const outputStride = 8;

        const FPS = 60;
        const video = document.getElementById('video');
        const fpsDisplay = document.getElementById('stats');

        await startVideo(video);

        video.width = video.videoWidth;
        video.height = video.videoHeight;

        const canvas = document.getElementById("output");

        canvas.width = w;
        canvas.height = h;

        const ctx = canvas.getContext("2d");

        ctx.beginPath();
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "black";
        ctx.fill();

        ctx.fillStyle = "#FF0000";

        let pose //= await net.estimateSinglePose(video, imageScaleFactor, flipHorizontal, outputStride);;

        let begin, delay; // fps helpers
        async function processVideo() {
            begin = Date.now();
            stats.update();

            if (canvas.width >= canvas.height)
                ctx.drawImage(video, 0, (canvas.height / 2) - (canvas.width * video.height / video.width / 2), canvas.width, canvas.width * video.height / video.width);
            else
                ctx.drawImage(video, (canvas.width / 2) - (canvas.height * video.width / video.height / 2), 0, canvas.height * video.width / video.height, canvas.height);

            pose = await net.estimateSinglePose(ctx.getImageData(0, 0, canvas.width, canvas.height), imageScaleFactor, flipHorizontal, outputStride);


            for (let keypoint of pose.keypoints) {
                if (keypoint.score > 0.5) {
                    const circle = new Path2D();
                    circle.arc(keypoint.position.x, keypoint.position.y, 3, 0, 2 * Math.PI);
                    ctx.fill(circle);
                    ctx.stroke(circle);
                }
            }

            delay = 1000 / FPS - (Date.now() - begin);
            setTimeout(() => {
                // fpsDisplay.innerText = (1000 / (Date.now() - begin)).toFixed(0);
                processVideo();
            }, delay);
        }

        setTimeout(processVideo, 0);

        gui.add(controls, 'size', 0.1, 1.0, 0.05).onChange(change);

        function change() {
            w = controls.size * window.innerWidth;
            h = controls.size * window.innerHeight;

            canvas.width = w //video.videoWidth;
            canvas.height = h //video.videoHeight;

            ctx.beginPath();
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "black";
            ctx.fill();

            ctx.fillStyle = "#FF0000";
        }
        window.addEventListener('resize', change, false);
    });


    async function startVideo(video) {
        let stream; // video stream

        const constraints = {
            video: {
                facingMode: "user",
                width: { ideal: 4096 },
                height: { ideal: 2160 }
            },
            audio: false
        }

        try {
            stream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = stream;
            video.play();

            return new Promise(function (resolve, reject) {
                video.addEventListener('loadeddata', function () {
                    resolve();
                });
            });
        }
        catch (err) {
            console.error('Error accesing camera:', err);
            alert('Error accessing camera')
        }
    }

    function initStats() {
        let stats = new Stats();
        stats.setMode(0); // 0: fps, 1: ms

        // Align top-left
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';
        document.getElementById('body').appendChild(stats.domElement);

        return stats;
    }
</script>

</html>