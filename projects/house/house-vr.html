<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>House VR</title>
    <link rel="stylesheet" href="../../css/w3.css">
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* a {
            color: var(--color-blue);
            cursor: pointer;
            text-decoration: none;
        }

        #newWindow {
            display: block;
            position: absolute;
            bottom: 0em;
            left: 0.4em;
            color: #fff;
            text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;
        } */

        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(7, 7, 9, 0.5);
            display: none;
            z-index: 1000;
        }

        #instructions {
            color: #ffffff;
            font-size: 1.8em;
            width: 70%;
            z-index: 1001;
        }
    </style>

    <!-- Library of Virtual Reality -->
    <script type="text/javascript" charset="UTF-8" src="../libs/aframe-master.js"></script>
    <script type="text/javascript" charset="UTF-8" src="../libs/aframe-extras.js"></script>
    <script src="../libs/aframe-teleport-controls1.js"></script>

    <script>
        let stairs, floor = [], isFlying = false;

        AFRAME.registerComponent('modify-materials', {
            init: function () {
                // Wait for model to load.
                this.el.addEventListener('model-loaded', () => {
                    // Grab the mesh
                    const obj = this.el.getObject3D('mesh');

                    obj.scale.set(1.3, 1.3, 1.3);

                    obj.children.forEach(element => {
                        if (/window/i.test(element.name)) {
                            element.children[0].material.transparency = true;
                            element.children[0].material.opacity = 0.7;
                            floor.push(element.children[1])
                        } else if (/water/i.test(element.name)) {
                            element.material.transparency = true;
                            element.material.opacity = 0.7;
                        } else if (/stairs/i.test(element.name)) {
                            stairs = element;
                        } else if (/ground|stairs|floor/i.test(element.name)) {
                            floor.push(element);
                        }
                        else if (/balcony|patio/i.test(element.name)) {
                            floor.push(element.children[1]);
                        }
                    });
                });
            }
        });

        AFRAME.registerComponent('listen-gamepad', {
            init: function () {
                const self = this;
                // mobile buttons indexes
                self.goDown = 4;
                self.goUp = 5;

                window.addEventListener("gamepadconnected", function (e) {
                    console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
                        e.gamepad.index, e.gamepad.id,
                        e.gamepad.buttons.length, e.gamepad.axes.length);

                    if (e.gamepad.buttons.length === 12) {
                        // desktop buttons indexes
                        self.goDown = 6;
                        self.goUp = 7;
                    }
                });

                // this.el.components['movement-controls'].nextData['fly'] = true;
            },
            // tick: function (time, delta) {
            //     let gamepad = navigator.getGamepads()[0];

            //     if (gamepad) {
            //         let position = this.el.object3D.position

            //         if (gamepad.buttons[this.goUp].pressed) {
            //             position.y += 0.005 * delta;
            //             isFlying = true;
            //         }
            //         else if (gamepad.buttons[this.goDown].pressed && position.y > 0) {
            //             position.y -= 0.005 * delta;
            //         }
            //     }
            // }
        });

        AFRAME.registerComponent('camera-collision', {
            init: function () {
                this.height = this.el.getAttribute('position').y
                this.parentPos = this.el.parentEl.object3D.position

                this.raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0).normalize(), 0, this.height + 0.5);
                this.pos = new THREE.Vector3(this.parentPos.x, this.height, this.parentPos.z);
            },
            tick: function (time, delta) {
                if (stairs) {
                    this.parentPos = this.el.parentEl.object3D.position
                    this.pos.x = this.parentPos.x;
                    this.pos.y = this.parentPos.y + this.height;
                    this.pos.z = this.parentPos.z;
                    this.raycaster.ray.origin.copy(this.pos);

                    let intersectStairs = this.raycaster.intersectObject(stairs)[0];
                    if (intersectStairs) {
                        if (intersectStairs.distance <= this.height) {
                            this.parentPos.y += (this.height - intersectStairs.distance - 0.1);
                        }
                        else {
                            this.parentPos.y -= (intersectStairs.distance - this.height + 0.1);
                        }
                    }
                    else {
                        let intersectFloor = this.raycaster.intersectObjects(floor)[0]
                        if (intersectFloor) {
                            if (intersectFloor.distance < this.height) {
                                this.parentPos.y += (this.height - intersectFloor.distance);
                                isFlying = false;
                            }
                        }
                        else if (!isFlying) {
                            if (this.parentPos.y >= -0.6) {
                                this.parentPos.y -= 0.005 * delta
                            }
                        }
                    }
                }
            }
        });

        AFRAME.registerComponent('teleport', {
            init: function () {
                this.gamepad = {};
                this.canTeleport = false;
                this.velocity = 0.005
                this.rotation = 0;
                this.distance = 3;
                this.height = 0.2;
                this.raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(), 0);
                this.direction = new THREE.Vector3();

                let self = this
                window.addEventListener("gamepadconnected", function (e) {
                    console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
                        e.gamepad.index, e.gamepad.id,
                        e.gamepad.buttons.length, e.gamepad.axes.length);

                    self.canTeleport = true;
                });

                // let teleportTexture = new THREE.TextureLoader().load('../assets/textures/teleport.png');
                this.teleportMark = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.5, 0.2, 20, 1, true),
                    new THREE.MeshBasicMaterial({
                        color: 0xAA77DD,
                        side: THREE.DoubleSide
                    })
                );

                this.teleportMark.position.set(-3, 0, 15);

                this.el.parentEl.setObject3D('telep', this.teleportMark);

                // curve
                // var geometry = new THREE.BufferGeometry();
                // var positions = new Float32Array(6); // 3 vertices per point
                // geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                let pos = this.el.object3D.position.clone();
                pos.y += 1;
                var geometry = new THREE.BufferGeometry().setFromPoints([
                    pos,
                    this.teleportMark.position
                ])
                // material
                var material = new THREE.LineBasicMaterial({ color: 0x8855AA, linewidth: 5 });
                // line
                // this.line = new THREE.Line(geometry, material);

                // this.line.geometry.attributes.position.array[0] = this.el.object3D.position.x;
                // this.line.geometry.attributes.position.array[1] = this.el.object3D.position.y + 1.4;
                // this.line.geometry.attributes.position.array[2] = this.el.object3D.position.z;

                // this.line.geometry.attributes.position.array[3] = this.teleportMark.position.x;
                // this.line.geometry.attributes.position.array[4] = this.teleportMark.position.y;
                // this.line.geometry.attributes.position.array[5] = this.teleportMark.position.z;

                // this.el.sceneEl.setObject3D('line', this.line)
                var points = [];
                // points.push(pos);
                // points.push(this.teleportMark);
                points.push(pos)
                points.push(this.teleportMark.position)
                console.log(this.el.object3D.position)

                this.mat = new THREE.MeshBasicMaterial({
                    color: 0xAA77DD,
                    side: THREE.DoubleSide,
                });
                var tubeGeometry = new THREE.TubeBufferGeometry(new THREE.LineCurve3(points[0], points[1]), 64, 0.05, 8, true);
                this.tube = new THREE.Mesh(tubeGeometry, this.mat);

                console.log(this.tube.geometry.parameters)
                this.el.sceneEl.setObject3D('line', this.tube)
                this.test = true;
            },
            tick: function (time, delta) {
                this.gamepad = navigator.getGamepads()[0];

                this.rotation = this.el.children[0].object3D.rotation.y

                this.teleportMark.position.x = this.el.object3D.position.x + Math.cos(this.rotation - Math.PI * 0.5) * -this.distance;
                this.teleportMark.position.z = this.el.object3D.position.z + Math.sin(this.rotation - Math.PI * 0.5) * this.distance;

                if (this.test) {
                    let obj = this.el.object3D.position.clone();
                    obj.y += 1.2;
                    let tel = this.teleportMark.position.clone();
                    // let a = new THREE.Vector3(-3, 0, 18);
                    tel.y -= 1;
                    this.tube = new THREE.Mesh(
                        new THREE.TubeBufferGeometry(new THREE.LineCurve3(obj, tel), 64, 0.05, 8, true),
                        this.mat
                    );
                    this.el.sceneEl.setObject3D('line', this.tube);

                    var matrixWorld = this.el.object3D.matrixWorld;
                    var quaternion = new THREE.Quaternion();
                    matrixWorld.decompose(new THREE.Vector3(), quaternion, new THREE.Vector3());
                    var direction = new THREE.Vector3().set(0, 0, -1)
                        .applyQuaternion(quaternion).normalize();

                    console.log('>', direction);

                    // this.raycaster.set(this.el.object3D.position, new THREE.Vector3().subVectors(a, pos))
                    // this.raycaster.ray.origin.copy(this.el.object3D.position);
                    // this.raycaster.ray.direction = new THREE.Vector3(sqrt(tel.x - tel.y), -1, -3)
                    // this.raycaster.ray.direction.copy(this.direction.subVectors(a, pos));
                    // let intersectFloor = this.raycaster.intersectObjects(floor)
                    // console.log(intersectFloor, this.raycaster.ray);
                    this.test = false;
                }

                if (typeof this.gamepad === 'undefined' || typeof this.gamepad == 'null') {
                    return
                }

                if (this.gamepad.axes[1] !== 0) {
                    this.distance += this.velocity * delta * this.gamepad.axes[1] * -1;
                    this.raycaster.far = this.distance + 3;
                }

                if (this.canTeleport && this.gamepad.buttons.some(btn => btn.pressed)) {
                    this.el.object3D.position.x = this.teleportMark.position.x;
                    this.el.object3D.position.y = this.teleportMark.position.y - this.height;
                    this.el.object3D.position.z = this.teleportMark.position.z;

                    // this.teleportMark.position.x += -2 * Math.sin(this.rotation);
                    // this.teleportMark.position.z += -2 * Math.cos(this.rotation);
                    this.distance = 1.5;
                    this.canTeleport = false;
                    setTimeout(() => { this.canTeleport = true }, 500);
                    console.log('teleported')
                }

                // collision
                // if (stairs) { // if stairs object isn't null, the scene has loaded the collidable objects
                //     this.rayPos.x = this.teleportMark.position.x;
                //     this.rayPos.y = 1 + this.teleportMark.position.y;
                //     this.rayPos.z = this.teleportMark.position.z;

                //     this.raycaster.ray.origin.copy(this.teleportMark.position);

                //     let intersectStairs = this.raycaster.intersectObject(stairs)[0];
                //     if (intersectStairs) {
                //         this.teleportMark.position.y += (this.height - intersectStairs.distance);
                //     }
                //     else {
                //         let intersectFloor = this.raycaster.intersectObjects(floor)[0]
                //         if (intersectFloor) {
                //             this.teleportMark.position.y += (this.height - intersectFloor.distance)
                //         }
                //         else if (this.teleportMark.position.y >= -0.6) {
                //             this.teleportMark.position.y -= this.velocity * 0.5 * delta
                //         }
                //         else {
                //             this.teleportMark.position.y = 0.2;
                //         }
                //     }
                // }

            },
        });

        AFRAME.registerComponent('listener', {
            init: function () {
                window.addEventListener('controllerconnected', () => console.log('hi'))
                window.addEventListener('buttonchanged', () => console.log('hey'))
            }
        })
    </script>
</head>

<body>
    <div id="blocker" class="w3-display-container">

        <div id="instructions" class="w3-display-middle w3-center w3-white w3-opacity">
            <h1>Setting Controllers</h1>
            <p>Press one button to set it as the teleport button</p>
        </div>

    </div>

    <a-scene main_scene id="scene" blocker time light="defaultLightsEnabled: false"
        renderer="antialias: true; alpha: true">
        <a-assets timeout="60000">
            <a-asset-item id="house" src="../assets/models/modern-house.glb"></a-asset-item>
            <img id="skyBoxMap" src="../assets/textures/cloud.jpg">
        </a-assets>

        <a-entity id="rig" position="-3 0 18" movement-controls="controls: keyboard, touch" teleport teleport-controls>
            <a-entity id="camera" camera position="0 1.5 0" look-controls="pointerLockEnabled: true" camera-collision>
            </a-entity>
        </a-entity>

        <!-- <a-entity id="cameraRig">
            <a-entity id="head" camera position="0 1.5 0" wasd-controls look-controls gamepad-controls></a-entity>
            <a-entity id="left-hand" teleport-controls="cameraRig: #cameraRig; teleportOrigin: #head;"></a-entity>
            <a-entity id="right-hand" teleport-controls="cameraRig: #cameraRig; teleportOrigin: #head;"></a-entity>
        </a-entity> -->


        <a-entity light="type: ambient; color: #fff; intensity: 0.3"></a-entity>
        <a-entity light="color: #fff" position="65 110 52"></a-entity>

        <a-sky id="skyBox" material="src: #skyBoxMap"></a-sky>

        <a-entity id="house" gltf-model="#house" modify-materials></a-entity>

    </a-scene>>

</body>

</html>