<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>House VR</title>
    <link rel="stylesheet" href="../../css/w3.css">
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* a {
            color: var(--color-blue);
            cursor: pointer;
            text-decoration: none;
        }

        #newWindow {
            display: block;
            position: absolute;
            bottom: 0em;
            left: 0.4em;
            color: #fff;
            text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;
        } */
    </style>

    <!-- Library of Virtual Reality -->
    <script type="text/javascript" charset="UTF-8" src="../libs/aframe-master.js"></script>
    <script type="text/javascript" charset="UTF-8" src="../libs/aframe-extras.js"></script>
    <script src="../libs/aframe-teleport-controls1.js"></script>

    <script>
        let stairs = [], floor = [], isFlying = false;

        AFRAME.registerComponent('modify-materials', {
            init: function () {
                // Wait for model to load.
                this.el.addEventListener('model-loaded', () => {
                    // Grab the mesh
                    const obj = this.el.getObject3D('mesh');

                    obj.scale.set(1.3, 1.3, 1.3);

                    obj.children.forEach(element => {
                        if (/window/i.test(element.name)) {
                            element.children[0].material.transparency = true;
                            element.children[0].material.opacity = 0.7;
                            floor.push(element.children[1])
                        } else if (/water/i.test(element.name)) {
                            element.material.transparency = true;
                            element.material.opacity = 0.7;
                        } else if (/stairs/i.test(element.name)) {
                            stairs.push(element);
                            floor.push(element);
                        } else if (/ground|stairs|floor/i.test(element.name)) {
                            floor.push(element);
                        }
                        else if (/balcony|patio/i.test(element.name)) {
                            floor.push(element.children[1]);
                        }
                    });
                });
            }
        });

        AFRAME.registerComponent('listen-gamepad', {
            init: function () {
                const self = this;
                // mobile buttons indexes
                self.goDown = 4;
                self.goUp = 5;

                window.addEventListener("gamepadconnected", function (e) {
                    console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
                        e.gamepad.index, e.gamepad.id,
                        e.gamepad.buttons.length, e.gamepad.axes.length);

                    if (e.gamepad.buttons.length === 12) {
                        // desktop buttons indexes
                        self.goDown = 6;
                        self.goUp = 7;
                    }
                });

                // this.el.components['movement-controls'].nextData['fly'] = true;
            },
            // tick: function (time, delta) {
            //     let gamepad = navigator.getGamepads()[0];

            //     if (gamepad) {
            //         let position = this.el.object3D.position

            //         if (gamepad.buttons[this.goUp].pressed) {
            //             position.y += 0.005 * delta;
            //             isFlying = true;
            //         }
            //         else if (gamepad.buttons[this.goDown].pressed && position.y > 0) {
            //             position.y -= 0.005 * delta;
            //         }
            //     }
            // }
        });

        AFRAME.registerComponent('camera-collision', {
            init: function () {
                this.height = this.el.getAttribute('position').y
                this.parentPos = this.el.parentEl.object3D.position

                this.raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0).normalize(), 0, this.height + 0.5);
                this.pos = new THREE.Vector3(this.parentPos.x, this.height, this.parentPos.z);
            },
            tick: function (time, delta) {
                if (stairs) {
                    this.parentPos = this.el.parentEl.object3D.position
                    this.pos.x = this.parentPos.x;
                    this.pos.y = this.parentPos.y + this.height;
                    this.pos.z = this.parentPos.z;
                    this.raycaster.ray.origin.copy(this.pos);

                    let intersectStairs = this.raycaster.intersectObjects(stairs)[0];
                    if (intersectStairs) {
                        if (intersectStairs.distance <= this.height) {
                            this.parentPos.y += (this.height - intersectStairs.distance - 0.1);
                        }
                        else {
                            this.parentPos.y -= (intersectStairs.distance - this.height + 0.1);
                        }
                    }
                    else {
                        let intersectFloor = this.raycaster.intersectObjects(floor)[0]
                        if (intersectFloor) {
                            if (intersectFloor.distance < this.height) {
                                this.parentPos.y += (this.height - intersectFloor.distance);
                                isFlying = false;
                            }
                        }
                        else if (!isFlying) {
                            if (this.parentPos.y >= -0.6) {
                                this.parentPos.y -= 0.005 * delta
                            }
                        }
                    }
                }
            }
        });

        AFRAME.registerComponent('teleport', {
            init: function () {
                this.gamepad = null;
                this.obj = this.el.object3D;
                this.objPos = new THREE.Vector3();
                this.camera = document.querySelector('#camera');
                this.canTeleport = true;
                this.raycaster = new THREE.Raycaster();
                this.direction = new THREE.Vector3();
                this.rayDirection = new THREE.Vector3();
                this.intersection;
                this.time = 0;
                this.p1;
                this.p2;

                let self = this
                window.addEventListener("gamepadconnected", function (e) {
                    console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
                        e.gamepad.index, e.gamepad.id,
                        e.gamepad.buttons.length, e.gamepad.axes.length);

                    self.canTeleport = true;
                });

                window.addEventListener("keydown", (e) => {
                    if (e.keyCode == 32) this.teleport();
                    // else this.camera.object3D.position.y *= -1;
                });

                window.addEventListener('touchstart', (e) => {
                    this.teleport();
                })

                let material = new THREE.MeshBasicMaterial({
                    color: 0x7744AA,
                    side: THREE.DoubleSide,
                });

                this.obj.position.set(-3, 0, 18);

                this.objPos.copy(this.obj.position);
                this.objPos.y += 1.4;

                // let tubeGeometry = new THREE.TubeBufferGeometry(new THREE.LineCurve3(this.objPos, this.teleportMark.position), 1, 0.01, 5, false);
                // this.tube = new THREE.Mesh(tubeGeometry, material);

                // // this.el.sceneEl.setObject3D('tube', this.tube)

                this.curve = this.ProjectileCurve();
                this.path = new this.curve(this.objPos, 3 + camera.object3D.rotation.x * 5, Math.PI / 6, Math.PI / 2 + camera.object3D.rotation.y)

                this.telepRay = new THREE.Mesh(
                    new THREE.TubeBufferGeometry(this.path, 30, 0.01, 4, false),
                    material
                )
                this.time = this.quadratic(this.path.g / 2, this.path.vy, this.path.p0.y).x2
                // console.log(this.path.getPoint(this.time));

                this.teleportMark = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.5, 0.2, 20, 1, true),
                    material
                );

                this.el.parentEl.setObject3D('telep', this.teleportMark);

                this.el.sceneEl.setObject3D('telepRay', this.telepRay);
                this.test = true;
            },
            tick: function (time, delta) {
                this.gamepad = navigator.getGamepads()[0];

                // camera.object3D.getWorldDirection(this.direction);
                // this.direction.multiplyScalar(-1);
                // if (this.direction.y > -0.2) {
                //     this.direction.y = -0.2;
                // }

                this.objPos.copy(this.obj.position);
                this.objPos.y += 1.4;

                this.path = new this.curve(this.objPos, 3 + camera.object3D.rotation.x * 5, Math.PI / 6, Math.PI / 2 + camera.object3D.rotation.y)
                this.telepRay.geometry = new THREE.TubeBufferGeometry(this.path, 30, 0.01, 4, false);
                this.telepRay.geometry.needsupdate = true;

                if (this.test) {
                    // this.test = false;
                    // console.log(floor);
                    this.time = this.quadratic(this.path.g / 2, this.path.vy, this.path.p0.y).x2 / this.telepRay.geometry.parameters.tubularSegments;
                    for (let i = 0; i < this.telepRay.geometry.parameters.tubularSegments * 2; i++) {
                        this.p1 = i === 0 ? this.path.getPoint(this.time * i++) : this.p2;
                        this.p2 = this.path.getPoint(this.time * i);

                        this.raycaster.far = this.p1.distanceTo(this.p2);
                        this.raycaster.set(this.p1, this.direction.subVectors(this.p2, this.p1).normalize());
                        this.intersection = this.raycaster.intersectObjects(floor);

                        // console.log(this.intersection[0])
                        // console.log({ p1: this.p1, p2: this.p2 });
                        if (this.intersection[0]) {
                            // console.log('colided')
                            this.teleportMark.position.copy(this.intersection[0].point);
                            this.teleportMark.position.y += 0.15;
                            break;
                        }

                        // let helper = new THREE.ArrowHelper(this.raycaster.ray.direction, this.p1, this.p1.distanceTo(this.p2), 0xff0000);
                        // this.el.sceneEl.setObject3D('help' + i, helper);
                    }

                }

                // this.raycaster.far = 9
                // this.raycaster.set(this.objPos, this.direction);
                // this.intersection = this.raycaster.intersectObjects(floor);

                // if (this.intersection[0] && this.intersection[0].face.normal.x == 0 && this.intersection[0].face.normal.z == 0) {
                //     this.teleportMark.position.copy(this.intersection[0].point);
                //     this.teleportMark.position.y += 0.15;
                // }

                // this.tube.geometry = new THREE.TubeBufferGeometry(new THREE.LineCurve3(this.objPos, this.teleportMark.position), 1, 0.01, 5, false);
                // this.tube.geometry.needsupdate = true;



                // this.teleportMark.position.copy(this.path.getPoint(this.quadratic(this.path.g / 2, this.path.vy, this.path.p0.y).x2));

                if (!this.gamepad) return;

                if (this.gamepad.buttons.some(btn => btn.pressed)) {
                    this.teleport();
                }

            },
            teleport: function () {
                if (this.canTeleport) {
                    this.obj.position.x = this.teleportMark.position.x;
                    this.obj.position.y = this.teleportMark.position.y;
                    this.obj.position.z = this.teleportMark.position.z;
                    this.canTeleport = false;
                    setTimeout(() => { this.canTeleport = true }, 500);
                    console.log('teleported')
                }
            },
            curve: function (p0, p, v, theta) {
                let group = new THREE.Group();
                let material = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 5 });
                let size = 10;
                let points = [];

                // x-axis: p = p0 + vt
                // y-axis: p = p0 + vt + gt^2 * 0.5
                let vxz = v * Math.cos(theta);
                let vy = v * Math.sin(theta);
                let vx = vxz * Math.cos(theta)
                let vz = vxz * Math.cos(theta)
                // console.log({ v, vy });
                let time = this.quadratic(-4.9, vy, p0.y).x2 / size;
                let t;
                // console.log({ time });
                let x = -2.5, y, z = 0;
                for (let i = 0; i < size; i++) {
                    // points = [];
                    t = time * i;

                    x = p0.x + vx * t;
                    z = p0.z - vz * t;
                    y = p0.y + (vy * t) + (- 4.9 * (t * t));
                    points.push(new THREE.Vector3(x, y, z));
                    // console.log({ x, y, z });

                    i++;
                    t = time * i;

                    x = p0.x + vx * t;
                    z = p0.z - vz * t;
                    y = p0.y + (vy * t) + (- 4.9 * (t * t));
                    points.push(new THREE.Vector3(x, y, z));
                    // console.log({ x, y, t });
                    // points.push(p);
                    // console.log(points);


                }
                // let tubeGeometry = new THREE.TubeBufferGeometry(points, 1, 0.01, 5, false);
                // let tube = new THREE.Mesh(tubeGeometry, new THREE.MeshBasicMaterial({ color: 0x0000ff }))
                group.add(new THREE.Line(
                    new THREE.BufferGeometry().setFromPoints(points),
                    material
                ))
                // group.position.set(-3, 3, 15);
                // console.log(group)
                // return group;

                this.el.sceneEl.setObject3D('li', group);

                // -----------------------------------------
                function ProjectileCurve(p0, velocity, verticalAngle, horizontalAngle, gravity, scale) {
                    THREE.Curve.call(this);

                    if (p0 === undefined || velocity === undefined || verticalAngle === undefined || horizontalAngle === undefined) {
                        return null;
                    }

                    let vhorizontal = velocity * Math.cos(verticalAngle);

                    this.p0 = p0;
                    this.vy = velocity * Math.sin(verticalAngle);
                    this.vx = velocity * Math.cos(horizontalAngle);
                    this.vz = velocity * Math.sin(horizontalAngle);
                    this.g = (gravity === undefined) ? -9.8 : gravity;
                    this.scale = (scale === undefined) ? 1 : scale;

                    if (this.g > 0) this.g *= -1;
                    p0.x += 0.05;
                    // p0.y += 0.1;

                }
                ProjectileCurve.prototype = Object.create(THREE.Curve.prototype);
                ProjectileCurve.prototype.constructor = ProjectileCurve;

                ProjectileCurve.prototype.getPoint = function (t) {
                    let x = this.p0.x + this.vx * t * this.scale;
                    let y = this.p0.y + ((this.vy * t) + (this.g * 0.5 * (t * t))) * this.scale;
                    let z = this.p0.z - this.vz * t * this.scale;
                    return new THREE.Vector3(x, y, z);

                };

                var path = new ProjectileCurve(p0, 5, 1.07, Math.PI / 2, -9.8, 1);
                var geometry = new THREE.TubeBufferGeometry(path, 30, 0.01, 4, false);
                var materia = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                var mesh = new THREE.Mesh(geometry, materia);
                // this.el.sceneEl.setObject3D('hey', mesh);
                return ProjectileCurve
            },
            ProjectileCurve: function () {
                function ProjectileCurve(p0, velocity, verticalAngle, horizontalAngle, gravity, scale) {
                    THREE.Curve.call(this);

                    if (p0 === undefined || velocity === undefined || verticalAngle === undefined || horizontalAngle === undefined) {
                        return null;
                    }

                    let vhorizontal = velocity * Math.cos(verticalAngle);

                    this.p0 = p0;
                    this.vy = velocity * Math.sin(verticalAngle);
                    this.vx = velocity * Math.cos(horizontalAngle);
                    this.vz = velocity * Math.sin(horizontalAngle);
                    this.g = (gravity === undefined) ? -9.8 : gravity;
                    this.scale = (scale === undefined) ? 1 : scale;

                    if (this.g > 0) this.g *= -1;
                    p0.x += 0.05;

                }
                ProjectileCurve.prototype = Object.create(THREE.Curve.prototype);
                ProjectileCurve.prototype.constructor = ProjectileCurve;

                ProjectileCurve.prototype.getPoint = function (t) {
                    let x = this.p0.x + this.vx * t * this.scale;
                    let y = this.p0.y + ((this.vy * t) + (this.g * 0.5 * (t * t))) * this.scale;
                    let z = this.p0.z - this.vz * t * this.scale;
                    return new THREE.Vector3(x, y, z);

                };

                return ProjectileCurve
            },
            quadratic: function (a, b, c) {
                let delta = (b * b) - 4 * a * c;
                if (delta < 0) return -1;

                if (delta === 0) {
                    return -b / 2 * a;
                }

                let x1, x2;

                x1 = (-b + Math.sqrt(delta)) / (2 * a);
                x2 = (-b - Math.sqrt(delta)) / (2 * a);
                // console.log({ a, b, c, delta, sqrt: Math.sqrt(delta), x1, x2 })
                return { x1, x2 };


            }
        });

        AFRAME.registerComponent('listener', {
            init: function () {
                window.addEventListener('controllerconnected', () => console.log('hi'))
                window.addEventListener('buttonchanged', () => console.log('hey'))
            }
        })
    </script>
</head>

<body>
    <a-scene main_scene id="scene" blocker time light="defaultLightsEnabled: false"
        renderer="antialias: true; alpha: true">
        <a-assets timeout="60000">
            <a-asset-item id="house" src="../assets/models/modern-house.glb"></a-asset-item>
            <img id="skyBoxMap" src="../assets/textures/cloud.jpg">
        </a-assets>

        <a-entity id="rig" position="-3 0 18" wasd-controls teleport>
            <a-entity id="camera" camera position="0 1.5 0" look-controls="pointerLockEnabled: true">
            </a-entity>
        </a-entity>

        <!-- <a-entity id="cameraRig">
            <a-entity id="head" camera position="0 1.5 0" wasd-controls look-controls gamepad-controls></a-entity>
            <a-entity id="left-hand" teleport-controls="cameraRig: #cameraRig; teleportOrigin: #head;"></a-entity>
            <a-entity id="right-hand" teleport-controls="cameraRig: #cameraRig; teleportOrigin: #head;"></a-entity>
        </a-entity> -->


        <a-entity light="type: ambient; color: #fff; intensity: 0.3"></a-entity>
        <a-entity light="color: #fff" position="65 110 52"></a-entity>

        <a-sky id="skyBox" material="src: #skyBoxMap"></a-sky>

        <a-entity id="house" gltf-model="#house" modify-materials></a-entity>

    </a-scene>>

</body>

</html>